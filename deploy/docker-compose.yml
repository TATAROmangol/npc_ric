services:
  nginx:
      image: nginx
      container_name: nginx
      depends_on:
        auth: 
          condition: service_started
        forms:
          condition: service_started
        generator:
          condition: service_started
      ports:
        - "9000:9000"  
        - "80:80"      
      volumes:
        - ../nginx/nginx.conf:/etc/nginx/nginx.conf
        - ../nginx/video:/etc/nginx/video

  auth:
    container_name: auth
    depends_on:
      postgres:
        condition: service_healthy
    build: 
      context: ../auth
      dockerfile: Dockerfile
    environment:
      AUTH_HTTP_PORT: ${AUTH_HTTP_PORT}
      AUTH_HTTP_HOST: 0.0.0.0
      AUTH_GRPC_PORT: ${AUTH_GRPC_PORT}
      AUTH_GRPC_HOST: 0.0.0.0
      ADMIN_LOGIN: ${ADMIN_LOGIN}
      ADMIN_PASSWORD: ${ADMIN_PASSWORD}
      JWT_KEY: ${JWT_KEY}
    expose:
      - ${AUTH_HTTP_PORT}
      - ${AUTH_GRPC_PORT}

  forms:
    container_name: forms
    depends_on:
      postgres:
        condition: service_healthy
    build: 
      context: ../forms
      dockerfile: Dockerfile
    environment:
      FORMS_HTTP_PORT: ${FORMS_HTTP_PORT}
      FORMS_HTTP_HOST: 0.0.0.0
      FORMS_TABLE_GRPC_PORT: ${FORMS_TABLE_GRPC_PORT}
      FORMS_TABLE_GRPC_HOST: 0.0.0.0
      FORMS_AUTH_GRPC_PORT: ${FORMS_AUTH_GRPC_PORT}
      FORMS_AUTH_GRPC_HOST: nginx
      PG_HOST: postgres
      PG_PORT: ${PG_PORT}
      PG_USER: ${PG_USER}
      PG_PASSWORD: ${PG_PASSWORD}
      PG_DB_NAME: ${PG_DB_NAME}
      PG_SSL: ${PG_SSL}
    expose:
      - ${AUTH_HTTP_PORT}
      - ${AUTH_GRPC_PORT}

  generator:
    container_name: generator
    depends_on:
      postgres:
        condition: service_healthy
    build: 
      context: ../generator
      dockerfile: Dockerfile
    environment:
      FORMS_GRPC_HOST: forms
      FORMS_GRPC_PORT: 50050
      GEN_HTTP_PORT: 8082
      GEN_HTTP_HOST: 0.0.0.0
      GEN_GRPC_PORT: 9000
      GEN_GRPC_HOST: 0.0.0.0
      PG_HOST: postgres
      PG_PORT: ${PG_PORT}
      PG_USER: ${PG_USER}
      PG_PASSWORD: ${PG_PASSWORD}
      PG_DB_NAME: ${PG_DB_NAME}
      PG_SSL: ${PG_SSL}
    expose:
      - ${AUTH_HTTP_PORT}
      - ${AUTH_GRPC_PORT}
    ports:
      - "8082:8000"

  postgres:
    image: postgres:latest
    container_name: postgres
    environment:
      POSTGRES_USER: ${PG_USER}
      POSTGRES_PASSWORD: ${PG_PASSWORD}
      POSTGRES_DB: ${PG_DB_NAME}
      PGDATA: ${PG_DATA}
    ports:
      - ${OUT_PG_PORT}:${PG_PORT}
    volumes:
      - ${PG_VOLUME}:${PG_DATA}
    deploy:
      resources:
        limits:
          cpus: '0.50'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M
    command: >
      postgres -c max_connections=1000
               -c shared_buffers=256MB
               -c effective_cache_size=768MB
               -c maintenance_work_mem=64MB
               -c checkpoint_completion_target=0.7
               -c wal_buffers=16MB
               -c default_statistics_target=100
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U ${PG_USER} -d ${PG_DB_NAME}" ]
      interval: 30s
      timeout: 10s
      retries: 5
    restart: unless-stopped
    tty: true
    stdin_open: true

  kafka:
    image: bitnami/kafka:3.6
    container_name: kafka
    ports:
      - "9092:9092"
    environment:
      - KAFKA_CFG_NODE_ID=0
      - KAFKA_CFG_PROCESS_ROLES=controller,broker
      - KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=0@kafka:9093
      - KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093
      - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://kafka:9092
      - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT
      - KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER
      - KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE=true
      - KAFKA_KRAFT_CLUSTER_ID=cy5WKwDUY0qMJ2qccq8jbg==

    volumes:
      - ./kafka_data:/bitnami/kafka

volumes:
  pgdata:
    driver: local